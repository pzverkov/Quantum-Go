# Mathematical Foundation of Quantum-Go CH-KEM

**Version:** 1.0
**Security Level:** NIST Category 5 (AES-256 equivalent)
**Authors:** Quantum-Go Development Team

---

## Table of Contents

1. [Introduction](#1-introduction)
2. [Lattice-Based Cryptography Background](#2-lattice-based-cryptography-background)
3. [The Module Learning With Errors (MLWE) Problem](#3-the-module-learning-with-errors-mlwe-problem)
4. [ML-KEM-1024 Algorithm](#4-ml-kem-1024-algorithm)
5. [X25519 Elliptic Curve Diffie-Hellman](#5-x25519-elliptic-curve-diffie-hellman)
6. [CH-KEM: Cascaded Hybrid Key Encapsulation](#6-ch-kem-cascaded-hybrid-key-encapsulation)
7. [Security Proofs](#7-security-proofs)
8. [Parameter Selection Rationale](#8-parameter-selection-rationale)
9. [References](#9-references)

---

## 1. Introduction

This document provides the mathematical foundation for the Cascaded Hybrid Key Encapsulation Mechanism (CH-KEM) implemented in Quantum-Go. CH-KEM is designed to provide quantum-resistant security for VPN encryption while maintaining backward compatibility with classical cryptographic guarantees.

### 1.1 Security Goals

1. **IND-CCA2 Security**: Indistinguishability under adaptive chosen-ciphertext attacks
2. **Quantum Resistance**: Security against quantum computer attacks (Shor's algorithm)
3. **Hybrid Security**: System remains secure if either classical or post-quantum component is broken
4. **Forward Secrecy**: Compromise of long-term keys does not compromise past sessions

### 1.2 Notation

| Symbol | Description |
|--------|-------------|
| ℤ_q | Integers modulo q |
| R_q | Polynomial ring ℤ_q[X]/(X^n + 1) |
| ←$ | Sampled uniformly at random |
| ← | Deterministic assignment |
| || | Concatenation |
| H() | Cryptographic hash function |
| ⊕ | XOR operation |

---

## 2. Lattice-Based Cryptography Background

### 2.1 Lattices

A **lattice** Λ is a discrete additive subgroup of ℝ^n. Given linearly independent vectors b₁, ..., bₖ ∈ ℝ^n, the lattice generated by them is:

```
Λ = {∑_{i=1}^{k} zᵢbᵢ : zᵢ ∈ ℤ}
```

### 2.2 Hard Lattice Problems

The security of lattice-based cryptography relies on the computational hardness of certain lattice problems:

**Shortest Vector Problem (SVP):**
Given a lattice basis B, find the shortest non-zero vector v ∈ Λ(B).

**Closest Vector Problem (CVP):**
Given a lattice basis B and a target vector t, find the lattice vector v ∈ Λ(B) closest to t.

**Learning With Errors (LWE):**
Given pairs (aᵢ, bᵢ = ⟨aᵢ, s⟩ + eᵢ) where s is secret and eᵢ is small noise, recover s.

### 2.3 Quantum Resistance

Unlike factoring and discrete logarithm problems (broken by Shor's algorithm), lattice problems have no known efficient quantum algorithms. The best known quantum algorithms for SVP/CVP provide only a polynomial speedup over classical algorithms.

---

## 3. The Module Learning With Errors (MLWE) Problem

### 3.1 Definition

Let n, k, q be positive integers and let R_q = ℤ_q[X]/(X^n + 1) be a polynomial ring.

**MLWE Distribution:** For a secret s ∈ R_q^k and error distribution χ over R_q:

```
A_{s,χ} = {(a, ⟨a, s⟩ + e) : a ←$ R_q^k, e ← χ}
```

**MLWE Problem:** Distinguish between:
- Samples from A_{s,χ} for random s ←$ R_q^k
- Samples from the uniform distribution over R_q^k × R_q

### 3.2 Centered Binomial Distribution

The error distribution χ in ML-KEM is the centered binomial distribution CBD_η:

```
CBD_η: Sample (a₁, ..., a_η, b₁, ..., b_η) ←$ {0,1}^{2η}
       Return ∑ᵢ aᵢ - ∑ᵢ bᵢ
```

For ML-KEM-1024: η₁ = η₂ = 2, giving coefficients in {-2, -1, 0, 1, 2}.

### 3.3 Security Reduction

The MLWE problem can be reduced to the Ring-LWE problem, which in turn reduces to worst-case hard problems on ideal lattices (SVP on ideal lattices).

**Theorem (Langlois-Stehlé, 2015):** MLWE is at least as hard as RLWE for the same parameters.

---

## 4. ML-KEM-1024 Algorithm

### 4.1 Parameters

| Parameter | Value | Description |
|-----------|-------|-------------|
| n | 256 | Polynomial degree |
| k | 4 | Module rank |
| q | 3329 | Modulus (prime, q ≡ 1 mod 256) |
| η₁ | 2 | Secret/noise coefficient bound |
| η₂ | 2 | Ciphertext noise bound |
| d_u | 11 | Ciphertext compression bits |
| d_v | 5 | Ciphertext compression bits |

### 4.2 Key Generation

```
ML-KEM.KeyGen():
    d ←$ {0,1}^{256}                     // Random seed
    ρ, σ ← G(d)                          // Expand to (ρ, σ) via SHA3-512

    // Generate matrix A from seed ρ
    for i = 0 to k-1:
        for j = 0 to k-1:
            A[i][j] ← SampleNTT(XOF(ρ, i, j))

    // Sample secret and error
    s ← SampleCBD_η1(σ, 0..k-1)
    e ← SampleCBD_η1(σ, k..2k-1)

    ŝ ← NTT(s)
    ê ← NTT(e)

    // Compute public key: t = As + e
    t̂ ← Â ◦ ŝ + ê

    pk ← (Encode(t̂), ρ)                  // Public key
    sk ← (ŝ, pk, H(pk), z)              // Secret key (z is random)

    return (pk, sk)
```

### 4.3 Encapsulation

```
ML-KEM.Encaps(pk):
    m ←$ {0,1}^{256}                     // Random message
    (K̄, r) ← G(m || H(pk))              // Derive (shared secret, randomness)

    // Encrypt m with randomness r
    (u, v) ← Encrypt(pk, m, r)
    c ← (u, v)

    K ← KDF(K̄ || H(c))                  // Final shared secret

    return (c, K)
```

### 4.4 Decapsulation (Fujisaki-Okamoto Transform)

```
ML-KEM.Decaps(sk, c):
    (ŝ, pk, h, z) ← sk

    // Decrypt to recover m'
    m' ← Decrypt(sk, c)

    // Re-derive randomness
    (K̄', r') ← G(m' || h)

    // Re-encrypt with derived randomness
    c' ← Encrypt(pk, m', r')

    // Implicit rejection: if c ≠ c', return pseudorandom value
    if c = c':
        return KDF(K̄' || H(c))
    else:
        return KDF(z || H(c))           // Implicit rejection
```

### 4.5 Security Level

ML-KEM-1024 provides NIST Category 5 security:
- **Classical security:** ~256 bits (equivalent to AES-256)
- **Quantum security:** ~128 bits against Grover's algorithm
- **Core-SVP hardness:** Estimated 2^272 operations

---

## 5. X25519 Elliptic Curve Diffie-Hellman

### 5.1 Curve Definition

Curve25519 is a Montgomery curve over F_p where p = 2^255 - 19:

```
y² = x³ + 486662x² + x
```

### 5.2 Group Parameters

| Parameter | Value |
|-----------|-------|
| p | 2^255 - 19 |
| A | 486662 |
| Base point x | 9 |
| Order | 2^252 + 27742317777372353535851937790883648493 |

### 5.3 Scalar Multiplication

X25519 uses the Montgomery ladder for constant-time scalar multiplication:

```
X25519(k, u):
    // Clamp scalar k
    k[0] &= 248
    k[31] &= 127
    k[31] |= 64

    // Montgomery ladder (x-coordinate only)
    x₁ ← u
    x₂ ← 1
    z₂ ← 0
    x₃ ← u
    z₃ ← 1

    for i = 254 down to 0:
        bit ← (k >> i) & 1
        (x₂, x₃) ← cswap(bit, x₂, x₃)
        (z₂, z₃) ← cswap(bit, z₂, z₃)
        // Montgomery differential addition
        ...

    return x₂ × z₂^{p-2} mod p
```

### 5.4 Security Properties

- **CDH Security:** ~128 bits classical security
- **Constant-time:** Resistant to timing side-channels
- **Twist-secure:** Computations on the twist are equally hard
- **NOT quantum-resistant:** Vulnerable to Shor's algorithm

---

## 6. CH-KEM: Cascaded Hybrid Key Encapsulation

### 6.1 Construction

CH-KEM combines X25519 and ML-KEM-1024 to provide security if EITHER scheme is secure.

**Key Generation:**
```
CH-KEM.KeyGen():
    (pk_x, sk_x) ← X25519.KeyGen()
    (pk_m, sk_m) ← ML-KEM.KeyGen()

    pk ← pk_x || pk_m
    sk ← (sk_x, sk_m)

    return (pk, sk)
```

**Encapsulation:**
```
CH-KEM.Encaps(pk):
    (pk_x, pk_m) ← Parse(pk)

    // Generate ephemeral X25519 key
    (pk_x_eph, sk_x_eph) ← X25519.KeyGen()

    // X25519 shared secret
    K_x ← X25519.DH(sk_x_eph, pk_x)

    // ML-KEM encapsulation
    (ct_m, K_m) ← ML-KEM.Encaps(pk_m)

    // Ciphertext
    ct ← pk_x_eph || ct_m

    // Transcript for binding
    transcript ← SHA3-256(pk_x || pk_m || ct)

    // Cascaded key derivation
    K ← SHAKE-256(K_x || K_m || transcript || "CH-KEM-v1-SharedSecret", 256)

    return (ct, K)
```

**Decapsulation:**
```
CH-KEM.Decaps(sk, ct):
    (sk_x, sk_m) ← sk
    (pk_x_eph, ct_m) ← Parse(ct)

    // X25519 shared secret
    K_x ← X25519.DH(sk_x, pk_x_eph)

    // ML-KEM decapsulation
    K_m ← ML-KEM.Decaps(sk_m, ct_m)

    // Recompute transcript
    pk_x ← X25519.PublicKey(sk_x)
    pk_m ← ML-KEM.PublicKey(sk_m)
    transcript ← SHA3-256(pk_x || pk_m || ct)

    // Cascaded key derivation
    K ← SHAKE-256(K_x || K_m || transcript || "CH-KEM-v1-SharedSecret", 256)

    return K
```

### 6.2 Key Sizes

| Component | Size (bytes) |
|-----------|--------------|
| X25519 public key | 32 |
| ML-KEM-1024 public key | 1568 |
| **CH-KEM public key** | **1600** |
| X25519 ciphertext | 32 |
| ML-KEM-1024 ciphertext | 1568 |
| **CH-KEM ciphertext** | **1600** |
| **Shared secret** | **32** |

---

## 7. Security Proofs

### 7.1 Theorem: CH-KEM IND-CCA2 Security

**Theorem:** CH-KEM is IND-CCA2 secure if either:
1. X25519 is CDH-secure on Curve25519, OR
2. ML-KEM-1024 is IND-CCA2 secure (MLWE assumption)

under the random oracle model for SHAKE-256.

**Proof Sketch:**

Assume an adversary A breaks CH-KEM with non-negligible advantage ε.

**Game 0:** Original IND-CCA2 game for CH-KEM.

**Game 1:** Replace SHAKE-256 with a random oracle H.

**Game 2:** In the challenge ciphertext, replace K_x with a random value K̃_x.

If X25519 is CDH-secure, Games 1 and 2 are indistinguishable. An adversary distinguishing them can be used to solve CDH.

**Game 3:** In the challenge ciphertext, replace K_m with a random value K̃_m.

If ML-KEM is IND-CCA2 secure, Games 2 and 3 are indistinguishable.

**Game 4:** In Game 3, both K_x and K_m are random. The output K = H(K̃_x || K̃_m || transcript || domain) is uniformly random in the random oracle model.

In Game 4, the adversary has zero advantage.

**Conclusion:** ε ≤ ε_CDH + ε_MLKEM + negl(λ)

If either ε_CDH or ε_MLKEM is negligible, then ε is negligible. ∎

### 7.2 Transcript Binding

The inclusion of the transcript hash provides:

1. **Key confirmation:** Ensures both parties computed the same shared secret
2. **Man-in-the-middle prevention:** Any modification to public keys changes K
3. **Forward secrecy:** Past transcripts don't help decrypt future sessions

---

## 8. Parameter Selection Rationale

### 8.1 ML-KEM-1024 Parameters

| Choice | Rationale |
|--------|-----------|
| n = 256 | Efficient NTT; smallest power of 2 providing sufficient security |
| k = 4 | NIST Category 5 security (~256-bit classical) |
| q = 3329 | Smallest prime ≡ 1 (mod 512) allowing NTT of length 256 |
| η = 2 | Balance between noise magnitude and decryption failure probability |

**Failure Probability:** < 2^-174 (negligible)

### 8.2 X25519 Parameters

Curve25519 was chosen for:
- Widely deployed and audited
- Constant-time implementations available
- 128-bit classical security
- Excellent performance

### 8.3 SHAKE-256 for KDF

SHAKE-256 provides:
- 256-bit preimage resistance
- 256-bit collision resistance
- Arbitrary output length (XOF)
- No length-extension attacks
- NIST-standardized (FIPS 202)

---

## 9. References

1. **NIST FIPS 203** - Module-Lattice-Based Key-Encapsulation Mechanism Standard (2024)

2. **Bos, J., et al.** - "CRYSTALS-Kyber: A CCA-Secure Module-Lattice-Based KEM" (2018)

3. **Bernstein, D.J.** - "Curve25519: New Diffie-Hellman Speed Records" (2006)

4. **Langlois, A., Stehlé, D.** - "Worst-Case to Average-Case Reductions for Module Lattices" (2015)

5. **Fujisaki, E., Okamoto, T.** - "Secure Integration of Asymmetric and Symmetric Encryption Schemes" (1999)

6. **NIST FIPS 202** - SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions (2015)

7. **NIST SP 800-56C** - Recommendation for Key-Derivation Methods in Key-Establishment Schemes (2018)

---

*Document Version: 1.0*
*Last Updated: 2026-01-18*
